<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Hamcrest | crafting code.]]></title>
  <link href="http://marcphilipp.github.com/blog/categories/hamcrest/atom.xml" rel="self"/>
  <link href="http://marcphilipp.github.com/"/>
  <updated>2012-02-12T21:47:36+01:00</updated>
  <id>http://marcphilipp.github.com/</id>
  <author>
    <name><![CDATA[Marc Philipp]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Primitive Matt(ch)ers?]]></title>
    <link href="http://marcphilipp.github.com/blog/2010/11/16/primitive-matt-ch-ers/"/>
    <updated>2010-11-16T20:34:00+01:00</updated>
    <id>http://marcphilipp.github.com/blog/2010/11/16/primitive-matt-ch-ers</id>
    <content type="html"><![CDATA[<p>The <a href="http://code.google.com/p/hamcrest/">Hamcrest project</a> provides a large number of matchers, i.e. declaratively defined predicates. Prominent uses of these matchers include testing and mocking libraries like JUnit and jMock, respectively.</p>

<h3>How to use them?</h3>

<p>```java
@Test
public void onePlusOneIsTwo() {</p>

<pre><code>assertThat(1 + 1, is(2));
</code></pre>

<p>}
```</p>

<p>While the above example is simple, it demonstrates one of the benefits of using <code>assertThat()</code> and Hamcrest matchers: assertions become very readable. Unfortunately, you often have to rely on a questionable Java mechanism: auto boxing/unboxing.</p>

<p>Auto boxing and unboxing have been introduced in Java 5 to ease the use of primitive types and their counterparts: <em>real</em> objects (a.k.a. reference types). However, especially unboxing can lead to hidden NullPointerExceptions and thus is discouraged by many developers. For details see <a href="http://pboop.wordpress.com/2010/09/22/autoboxing-is-evil/">Autoboxing is Evil</a> by Nicole Rauch and Andreas Leidig.</p>

<p>For this reason, the Eclipse Java compiler optionally shows warnings whenever boxing or unboxing occurs. While it is certainly a good idea to enable this warning, it also puts markers on code that is perfectly sane, like the test case above. To prevent un-/boxing and use matchers at the same time, one can go back to pre-Java 5 times and convert the
primitive literals explicitly:</p>

<p>```java
@Test
public void onePlusOneIsTwo() {</p>

<pre><code>assertThat(Integer.valueOf(1 + 1), is(Integer.valueOf(2)));
</code></pre>

<p>}
```</p>

<p>However, this is not readable anymore!</p>

<h3>Why do we need boxing in the first place?</h3>

<p>When using <code>assertThat()</code> we need boxing for two reasons. First, there is no definition of <code>assertThat()</code> for primitive types, only for reference types:</p>

<p><code>java
&lt;T&gt; void assertThat(T actual, Matcher&lt;T&gt; matcher)
</code></p>

<p>Well, why don't we overload <code>assertThat()</code> with separate method definitions for each primitive type, you might say.</p>

<p><code>java
void assertThat(int actual, Matcher&lt;int&gt; matcher)
</code></p>

<p>Java's generics do not allow primitive types like <code>int</code> as type arguments, only reference types are allowed.</p>

<h3>Hmm, anything we <em>can</em> do?</h3>

<p>Yes! So how about</p>

<p>```java
void assertThat(int actual, Matcher<Integer> matcher) {</p>

<pre><code>assertThat(Integer.valueOf(actual), matcher);
</code></pre>

<p>}
```</p>

<p>Without using auto boxing, we can now write:</p>

<p>```java
@Test
public void onePlusOneIsTwo() {</p>

<pre><code>assertThat(1 + 1, is(Integer.valueOf(2)));
</code></pre>

<p>}
```</p>

<p>That solves half of our problem: We got rid of the first boxing by overloading <code>assertEquals()</code>. However, we still need to explicity convert our <code>int</code> to <code>Integer</code> when calling the matcher factory method. Thus, we also need to overload the <code>is()</code> method:</p>

<p>```java
Matcher<Integer> is(int value) {</p>

<pre><code>return is(Integer.valueOf(value));
</code></pre>

<p>}
```</p>

<p>Problem solved! Really? Obviously, it requires a lot of work do define extra matcher factory methods for every combination of primitive type and matcher.</p>

<h3>Solution: generate it!</h3>

<p>Hamcrest already allows to <a href="http://code.google.com/p/hamcrest/wiki/Tutorial#Sugar_generation">generate matcher libraries</a>, i.e. classes that collect all static factory methods for easy access at a single entry point. So, we could simply generate extra methods for every matcher. To stay with the example from above, if we have an
unrestricted <code>Matcher&lt;T&gt;</code>, we would generate the following eight overloading methods:</p>

<p>```java
Matcher<Byte> is(byte value) {</p>

<pre><code>return is(Byte.valueOf(value));
</code></pre>

<p>}
Matcher<Short> is(short value) {</p>

<pre><code>return is(Short.valueOf(value));
</code></pre>

<p>}
Matcher<Integer> is(int value) {</p>

<pre><code>return is(Integer.valueOf(value));
</code></pre>

<p>}
Matcher<Long> is(long value) {</p>

<pre><code>return is(Long.valueOf(value));
</code></pre>

<p>}
Matcher<Float> is(float value) {</p>

<pre><code>return is(Float.valueOf(value));
</code></pre>

<p>}
Matcher<Double> is(double value) {</p>

<pre><code>return is(Double.valueOf(value));
</code></pre>

<p>}
Matcher<Boolean> is(boolean value) {</p>

<pre><code>return is(Boolean.valueOf(value));
</code></pre>

<p>}
Matcher<Character> is(char value) {</p>

<pre><code>return is(Character.valueOf(value));
</code></pre>

<p>}
```</p>

<p>A matcher declaration which uses the object representation of a primitive type, e.g. <code>Matcher&lt;Integer&gt;</code>, is a special case that is even more simple. We would only need to generate a single extra method, such as</p>

<p>```java
Matcher<Integer> zero(int value) {</p>

<pre><code>return zero(Integer.valueOf(value));
</code></pre>

<p>}
```</p>

<p>Summing up, it would be great if Hamcrest provided built-in support for primitive types.</p>

<h3>Update</h3>

<p>My proposal was <a href="http://code.google.com/p/hamcrest/issues/detail?id=130">rejected</a> by the Hamcrest maintainers.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Generic Matcher Pitfalls]]></title>
    <link href="http://marcphilipp.github.com/blog/2010/02/16/generic-matcher-pitfalls/"/>
    <updated>2010-02-16T22:45:00+01:00</updated>
    <id>http://marcphilipp.github.com/blog/2010/02/16/generic-matcher-pitfalls</id>
    <content type="html"><![CDATA[<p>Using <a href="http://code.google.com/p/hamcrest/">Hamcrest</a> matchers in combination with <code>assertThat</code> allows for more fluid specification of JUnit assertions.</p>

<p>Recently, while working on the backend of <a href="http://projectusus.org/">Project Usus</a>, we needed a simple matcher, that would test whether a given set is empty. At the time, we reused a set matcher we had already written a few minutes earlier.</p>

<p>Today, I had another look at the pre-defined matchers that come with Hamcrest and found the <code>empty()</code> matcher in <code>org.hamcrest.Matchers</code>. Since I'm not concerned with the actual implementation (at least for now), I'll just give you the factory method:</p>

<p>```java
@Factory
public static <E> Matcher&lt;Collection<E>> empty() {</p>

<pre><code>return new IsEmptyCollection&lt;E&gt;();
</code></pre>

<p>}
```</p>

<p>Great, I thought. So I readily changed our tests to use the pre-defined matcher…</p>

<p><code>java
assertThat(new TreeSet&lt;String&gt;(), empty());
</code></p>

<p>However, this yielded a compile error because the compiler could not infer the type parameter of the method. It <em>did</em> work when stating the type parameter of the static method explicitly:</p>

<p><code>java
assertThat(new TreeSet&lt;String&gt;(), Matchers.&lt;String&gt;empty());
</code></p>

<p>But that looked horrible. My first shot was to define an own factory method…</p>

<p>```java
@Factory
public static <E> Matcher&lt;Collection<E>> emptyOf(Class<E> clazz) {</p>

<pre><code>return new IsEmptyCollection&lt;E&gt;();
</code></pre>

<p>}
```</p>

<p>…that can be used like this:</p>

<p><code>java
assertThat(new TreeSet&lt;String&gt;(), emptyOf(String.class));
</code></p>

<p>I was still not very pleased with the solution. Even more since it does not matter at all what kind of objects are inside the collection to determine whether it is empty. After playing around for a little while I came up with this solution:</p>

<p>```java
public class IsEmptyCollection extends TypeSafeMatcher&lt;Collection&lt;?>> {</p>

<pre><code>@Override
protected boolean matchesSafely(Collection&lt;?&gt; collection) {
    return collection.isEmpty();
}

public void describeTo(Description description) {
    description.appendText("empty");
}

@Factory
public static Matcher&lt;Collection&lt;?&gt;&gt; empty() {
    return new IsEmptyCollection();
}
</code></pre>

<p>}
```</p>

<p>In conclusion, I think it is not trivial to write usable generic matchers. Therefore, avoid generics when you don't need them!</p>
]]></content>
  </entry>
  
</feed>
